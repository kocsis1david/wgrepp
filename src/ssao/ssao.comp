#extension GL_EXT_samplerless_texture_functions : require

layout(
    local_size_x = 8,
    local_size_y = 8,
    local_size_z = 1
) in;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 u_projection;
    vec2 u_uvToViewSpaceAdd;
    vec2 u_uvToViewSpaceMul;
    float u_depthAdd;
    float u_depthMul;
    uvec2 u_noiseOffset;
    uint u_sampleCount;
    float u_radius;
    float u_bias;
};

layout(set = 0, binding = 1) readonly buffer SamplesBuffer {
    vec4 u_samples[];
};

layout(r8, set = 0, binding = 2) writeonly uniform image2D u_outputTexture;
layout(set = 0, binding = 3) uniform texture2D u_depthTexture;
layout(rg16f, set = 0, binding = 4) readonly uniform image2D u_normalTexture;
layout(rg32f, set = 0, binding = 5) readonly uniform image2D u_noiseTexture;

float screenSpaceDepthToViewSpaceZ(float d) {
    return u_depthMul / (u_depthAdd - d);
}

float getViewSpaceZ(ivec2 p) {
    float d = texelFetch(u_depthTexture, p, 0).x;
    return screenSpaceDepthToViewSpaceZ(d);
}

vec3 getNormal(ivec2 coords) {
    vec2 n = imageLoad(u_normalTexture, coords).xy;
    float z = sqrt(1 - n.x * n.x - n.y * n.y);
    return vec3(n, z);
}

float getDepth(ivec2 coords) {
    return texelFetch(u_depthTexture, coords, 0).x;
}

vec3 uvToViewSpacePosition(vec2 uv, float depth) {
    float z = screenSpaceDepthToViewSpaceZ(depth);
    return vec3((uv * u_uvToViewSpaceMul + u_uvToViewSpaceAdd) * -z, z);
}

vec3 getRandomVec(uvec2 fragCoord) {
    ivec2 p = ivec2(fragCoord + u_noiseOffset) % imageSize(u_noiseTexture);
    return vec3(imageLoad(u_noiseTexture, p).xy, 0);
}

void main() {
    uvec2 outputSize = uvec2(imageSize(u_outputTexture));
    uvec2 fragCoord = gl_GlobalInvocationID.xy;

    if (!all(lessThan(fragCoord, outputSize))) {
        return;
    }

    float depth = getDepth(ivec2(fragCoord));
    if (depth == 1.0) {
        imageStore(u_outputTexture, ivec2(fragCoord), vec4(1));
        return;
    }

    vec2 fragUv = (vec2(fragCoord) + 0.5) / vec2(outputSize);
    vec3 viewPos = uvToViewSpacePosition(fragUv, depth);
    vec3 normal = getNormal(ivec2(fragCoord));
    vec3 randomVec = getRandomVec(fragCoord);

    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
    vec3 bitangent = cross(normal, tangent);
    mat3 tbn = mat3(tangent, bitangent, normal);

    float occlusion = 0.0;

    for (uint i = 0; i < u_sampleCount; i++) {
        vec3 sampleVec = u_radius * (tbn * u_samples[i].xyz);
        vec3 samplePos = viewPos + sampleVec;

        vec4 sampleClipPos = u_projection * vec4(samplePos, 1.0);
        vec2 sampleNdc = sampleClipPos.xy / sampleClipPos.w;
        vec2 sampleUv = sampleNdc * vec2(0.5, -0.5) + 0.5;
        ivec2 sampleCoords = ivec2(floor(sampleUv * outputSize));
        sampleCoords = clamp(sampleCoords, ivec2(0), ivec2(outputSize - 1));

        float z = getViewSpaceZ(sampleCoords);
        float rangeCheck = smoothstep(0.0, 1.0, u_radius / abs(viewPos.z - z));
        occlusion += (z >= samplePos.z + u_bias ? 1.0 : 0.0) * rangeCheck;
    }

    occlusion = 1.0 - (occlusion / u_sampleCount);
    imageStore(u_outputTexture, ivec2(fragCoord), vec4(occlusion));
}